<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Title</title>
  </head>
  <body>
    <div id="test">尚硅谷IT教育</div>

    <div id="demo">
      <ul>
        <li>test1</li>
        <li>test2</li>
        <li>test3</li>
      </ul>
    </div>

    <!--
      1. [].slice.call(lis): 将伪数组转换为真数组
      2. node.nodeType: 得到节点类型
      3. Object.defineProperty(obj, propertyName, {}): 给对象添加属性(指定描述符)
      4. Object.keys(obj): 得到对象自身可枚举属性组成的数组
      5. obj.hasOwnProperty(prop): 判断prop是否是obj自身的属性
      6. DocumentFragment: 文档碎片(高效批量更新多个节点)
      -->

    <script type="text/javascript">

    // var obj ={
    //   "0":123,
    //   1:666
    // }

    // function A(){
    //   var arg=[].slice.call(arguments);
    //   console.log(arg)
    //   this.a="1215"
    // }
    // var a = new A(1,2,3);
// 1. [].slice.call(lis): 将伪数组转换为真数组
//查找原型对象的方法:Array.prototype === [].__proto__ 
// prototype  构造函数才拥有的属性  Array.prototype.slice
// __proto__  实例对象才拥有的属性  [].__proto__.slice
// [].__proto__.slice.call(this指向,开始下标,结束下标)
// [].__proto__.slice.apply(this指向,[开始下标,结束下标])

// 面试题:call和apply的区别
// 相同点:都可以修改借调函数中的this指向
// 不同点:
//    call:向借调函数内部传入实参,需要分别传入给call
//    apply:向借调函数内部传入实参,一次性通过数组传递给apply

/* 面试题:什么是伪数组
      1.以下标存储数据
      2.具有length属性
      3.无法使用数组的方法
      举例:
        1.arguments
        2.document.getElementsByClassName
        3.document.querySelectorAll

*/

// 根据旧数组,生成新数组,并浅拷贝内部的内容
// 浅拷贝:将当前数组内部所有的数据复制一份(如果内容是引用数据类型,复制的是地址值)
// var arr =[1,2,{}];
// console.log(arr.slice(0,3),arr);


// console.dir(test)





//       2. node.nodeType: 得到节点类型
/*  
      1 元素节点
      2 属性节点
      3 文本节点
      11 文档碎片节点

*/






//       3. Object.defineProperty(obj, propertyName, {}): 给对象添加属性(指定描述符)
/*
var obj={
      name:"xiaoming"
      };

var obj={};

// 元属性,属性描述符
Object.defineProperty(obj,"_name",{
  configurable:false,//是否允许之后再次修改该属性的配置
  enumerable:true,//for...in  是否可以枚举
  writable:true,//是否只读
  value:"xiaoming"
})
//访问描述符,具有getter和setter方法的属性
Object.defineProperty(obj,"name",{
  configurable:false,//是否允许之后再次修改该属性的配置
  enumerable:true,//for...in  是否可以枚举
  // writable:true,//是否只读
  get:function(){
    return obj._name
  },
  set:function(value){
    // console.log(value)
    obj._name=value;
  }
  // get(){}

})
console.log(obj.name)
obj.name="xiaowang"
console.log(obj)

*/


// var obj={};

// // 元属性,属性描述符
// Object.defineProperty(obj,"_name",{
//   configurable:false,//是否允许之后再次修改该属性的配置
//   enumerable:true,//for...in  是否可以枚举
//   writable:true,//是否只读
//   value:"xiaoming"
// })
// //访问描述符,具有getter和setter方法的属性
// Object.defineProperty(obj,"name",{
//   configurable:false,//是否允许之后再次修改该属性的配置
//   enumerable:false,//for...in  是否可以枚举
//   // writable:true,//是否只读
//   get:function(){
//     return obj._name
//   },
//   set:function(value){
//     // console.log(value)
//     obj._name=value;
//   }
//   // get(){}

// })
// console.log(Object.keys(obj))
// console.log(Object.values(obj))




//       4. Object.keys(obj): 得到对象自身可枚举属性组成的数组
/*
Object.values(obj)
*/





//       5. obj.hasOwnProperty(prop): 判断prop是否是obj自身的属性
//   var arr = [1,2,3];
//   console.log(arr.hasOwnProperty("length"))
//   console.log(arr.hasOwnProperty("push"))
//   console.log("push" in arr)
// // 面试题:关键字in和hasOwnProperty的区别
// // in会顺着原型链往上找,hasOwnProperty只会查找自身

// // 需求:打印当前对象身上所有的属性
// Array.prototype.c = 6;
// for(key in arr){
//   if(arr.hasOwnProperty(key)){
//     console.log(key)
//   }
// }




//       6. DocumentFragment: 文档碎片(高效批量更新多个节点)
var fragment = document.createDocumentFragment();
// console.dir(fragment)
var test = document.querySelector('#test');
// fragment.appendChild(test)
var nodeList = [].slice.call(document.body.childNodes);
nodeList.forEach(function(item,index){
  // console.log(item,index)
  fragment.appendChild(item)
})


// console.dir(document.body.childNodes)


//7.js中6个false值
// false 0 NaN "" undefined null
    </script>
  </body>
</html>
